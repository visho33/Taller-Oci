# IIC2552 - Taller de Programación Olimpiada Chilena de Informática
## 2020

# Índice
* [Introducción](#introducci%C3%B3n)
* [Información Básica](#informaci%C3%B3n-b%C3%A1sica)
* [¿Cómo funciona el curso?](#c%C3%B3mo-funciona-el-curso)
  * [Competencias Semanales](#1-competencias-semanales)
  * [Asistencia](#2-asistencia)
  * [Bonuses](#3-bonuses)
* [Cálculo de la Nota Final](#c%C3%A1lculo-de-la-nota-final)
* [Temario tentativo del Semestre](#temario-tentativo-del-semestre)
* [Estoy pegad@, no sé resolver un problema, no se me ocurre, no sé implementarlo, ¿qué puedo hacer?](#estoy-pegad-no-sé-resolver-un-problema-no-se-me-ocurre-no-sé-implementarlo-qué-puedo-hacer)
* [**Reglas (Ética)**](#reglas-%C3%A9tica) <<<<<<<<<<<<<<<<<<<<<<<<<<<<< **TODOS** LEER ESTO POR FAVOR!!
* [Comentarios Adicionales](#comentarios-adicionales)
  * [Sobre lenguajes de programación](#sobre-lenguajes-de-programaci%C3%B3n)
  * [Sobre restricciones de tiempo y memoria en programación competitiva](#sobre-restricciones-de-tiempo-y-memoria-en-programaci%C3%B3n-competitiva)
  * [**Mensaje para Alumnos Nuevos**](#mensaje-para-alumnos-nuevos) <<<<<<<< **NOVATOS** RECUERDEN LEER ESTO
* [Recursos para consultar](#recursos-para-consultar)
  * [General](#general)
  * [Soluciones Regionales Latinoamericanas](#soluciones-de-regionales-latinoamericanas)
  * [Soluciones, Inputs y Outputs oficiales de Regionales Norteamericanas](#soluciones-inputs-y-outputs-oficiales-de-regionales-norteamericanas)
  * [Para aprender C++ (MUY RECOMENDADO)](#para-aprender-c-muy-recomendado)
  * [Material para Temas Específicos](#material-para-temas-espec%C3%ADficos)
    * [Tricks para problemas Ad-Hoc](#tricks-para-problemas-ad-hoc)
    * [Tips para implementación con C++](#tips-para-implementaci%C3%B3n-con-c)
    * [Backtracking](#backtracking)
    * [Binary & Ternary Search](#search)
    * [Dynamic Programming (DP)](#dynamic-programming-dp)
    * [Greedy](#greedy)
    * [Graphs](#graphs)
    * [Data Structures](#data-structures)
    * [Strings](#strings)
    * [Mathematics](#mathematics)
    * [Geometry](#geometry)
    * [Square Root Decomposition](#square-root-decomposition)
* [Contests](#contests)

# Introducción

En este taller aprenderás las técnicas y habilidades necesarias para resolver problemas algorítmicos de [programación competitiva](https://es.wikipedia.org/wiki/Usuario:Ltaravilse/Programaci%C3%B3n_competitiva) y poder participar en la [Olimpiada Chilena de Informatica](https://www.olimpiada-informatica.cl/) de este año.

Sin embargo, las habilidades que adquirirás en este taller van mucho más allá que simplemente participar en la OCI. Aquí aprenderás a programar en C++, lo que te puede ayudar en muchos aspectos de tu vida (podrás hacer que tu computador trabaje para ti). Además, ejercitarás tu pensamiento lógico y mejorarás tu creatividad para abordar diferentes tipos de problemas. Además, programar es muy divertido (al menos para mí) y puede ser un buen pasatiempo durante la pandemia.

# Información Básica
Discord:

Whatsapp:

Clases: Por definir

# Cómo funciona el curso

## 1) Competencias Semanales

Este curso es 100% práctico. La nota final dependerá de la resolución por parte del alumno de problemas de programación competitiva. Cada semana se publicará un *contest* (o competencia, en español). Los contests se caracterizan por lo siguiente:

* Se publicarán en [vjudge.net](https://vjudge.net), un sitio web que permite crear competencias utilizando problemas obtenidos de múltiples jueces online, con un scoreboard que se actualiza en tiempo real a medida que los participantes resuelven problemas. Para competir es necesario que te crees una cuenta en [vjudge.net](https://vjudge.net) y posteriormente que te unas con dicha cuenta a los contests a medida que estos vayan siendo publicados. Para facilitarnos el registro de problemas resueltos, te pedimos por favor que registres el **nickname** de tu cuenta en el siguiente spreadsheet: [link](https://docs.google.com/spreadsheets/d/1FSRolgJukhPfEhVgEwG7SFk91D1FUwVQje0mkaNIGIQ/edit?usp=sharing).

* Casi todas las competencias serán **individuales**, pero hacia el final del semestre habrán 1 o 2 competencias **grupales**. 

* En el caso de competencias grupales, les está permitido armar equipos de un máximo de 3 alumn@s. Un detalle: como vjudge.net no permite crear equipos, los integrantes de cada equipo deberán acordar una cuenta en común y registrar dicha cuenta + los nombres de los integrantes en un spreadsheet que se les compartirá oportunamente.

* En general los contests serán temáticos. Es decir, cada contest estará compuesto por problemas que se resuelven utilizando estrategias pertenecientes a una categoría o tema común (ej. fuerza bruta, geometría, grafos, strings, etc.). El tema del contest se avisará con anticipación junto con una recomendación de material de estudio que los alumnos podrán revisar antes de la clase.

* El primer módulo de cada clase (14:00 - 15:30) será de cátedra. La idea es revisar contenidos relevantes para el contest antes de que este comience. Esto significa revisar la teoría, ver códigos de ejemplo y quizá explicar la solución de algún problema introductorio que aparecerá en el contest.

* A partir del segundo módulo (15:30 en adelante) comenzará el contest. La idea es que el segundo y tercer módulo de la clase (15:30 - 18:30) los alumnos trabajen en sus computadores programando. Por esto se recomienda que cada uno traiga su laptop a la clase. Si no tienes laptop, por favor avisa al staff del curso con anticipación para poder coordinar laptops de repuesto.

* Salvo en contest grupales, **cada alumn@ debe programar su propia solución**. Sin embargo, está permitido, y es más **te animamos** a que discutas ideas con tus compañeros y compañeras si es que te sientes complicad@ con algún problema que no sabes cómo resolver. Es más, si alguien quiere pasar a la pizarra ya sea a explicar o guiar una discusión de un problema, es **súper bienvenido**. Además, tanto el profesor como el ayudante estaremos disponibles toda la clase para que nos hagas consultas si lo necesitas. 

* Los problemas de cada contest tendrán diferentes niveles de dificultad, y por lo tanto serás premiad@ con más o menos puntos según la dificultad de los problemas que resuelvas. Por ej. un problema fácil te podría dar 1 punto, mientras que un problema muy difícil te podría dar más de 4 o 5 puntos. Estos puntajes se mantendrán intencionalmente ocultos hasta el final de la clase :)
   * UPDATE:  regalado (1), fácil (2), medio-fácil (3), medio (4), medio-difícil (5), difícil (6), muy difícil (7), **demasiado** difícil (8 o más)

* En general los contests tendrán una duración de un poco más de una semana (9 o 10 días), lo cual implica que durante los últimos días habrá algo de traslapo con el contest de la siguiente semana. No obstante, con el fin de que se acostumbren a programar contra reloj, habrá una penalización por resolver problemas pasado un cierto horario. En concreto, cada problema resuelto entre las 15:30 y las 23:59 del día que comenzó el contest proporcionará su puntaje original. En cambio, problemas que se resuelvan pasadas las 23:59 serán penalizados por un factor de 0.8. Es decir, _puntaje_tarde_ = _puntaje_original_ * 0.8

* Al final del semestre habrá un contest de repechaje. Este contest tendrá muchos problemas y durará hasta la fecha del cierre de notas. Sin embargo, el puntaje de estos problemas será penalizado con un factor de 0.5. Es decir, _puntaje_repechaje_ = _puntaje_original_ * 0.5. Por lo tanto, el consejo obvio es resolver problemas periódicamente de forma responsable, para no tener que trabajar el doble en el contest de repechaje :)

## 2) Asistencia

El curso es con **asistencia reprobatoria**. Los alumnos que registren una asistencia al final del semestre inferior a 65% **reprobarán el curso**. Cada clase se pasará lista. Aunque no es necesario que te quedes los 3 módulos, con que vengas al menos a 1 módulo es suficiente para quedar presente.

## 3) Bonuses

Además de las competencias semanales, existen varias formas de obtener décimas de bonus que se sumarán directamente a tu nota final:

* __BONUS EXPLICACIÓN PROBLEMA__ (individual): Este bonus permite obtener hasta un máximo de 2 décimas por explicación. ¿En qué consiste? Cada semana, junto a cada contest se publicará un google doc que será compartido con todos (todos podrán editarlo). La idea de estos google docs es que todos (alumnos y staff) colaboremos en la redacción de explicaciones de las soluciones de los problemas, armando una suerte de "wikipedia" de soluciones. ¿Cómo obtener este bonus?:  
  * Para obtener este bonus el primer requisito es haber resuelto el problema que quieres explicar (no puedes explicar un problema que no has resuelto todavía).
  * El segundo requisito es redactar la explicación **ANTES** que se acabe el contest (para que le sirva a alguien)
  * Debes redactar una explicación entendible de la estrategia con la cual resolviste el problema. Puedes agregar dibujos, imágenes, fórmulas, ecuaciones, etc. si crees que hará tu explicación más fácil de entender.
  * Opcionalmente, puedes incluir un link al código de tu solución (por ej. hosteado en un repositorio público en GitHub) al final de tu explicación.
  * Por supueto, no olvides incluir tu nombre y apellido al final de tu explicación para que todos sepan quién lo escribió.
  * Cuando tengas tu explicación lista, debes avisar por medio del Telegram del curso que has agregado una explicación.
  * La cantidad de décimas que recibas dependerá de varios factores, a saber:
    * La dificultad del problema resuelto
    * La calidad de la explicación (lo ideal: una explicación muy clara pero concisa)
    * Si tu explicación es realmente un aporte (en caso de que alguien más ya haya escrito una explicación para el mismo problema)
    * Si tu explicación incluye un análisis / estimación de la complejidad computacional del algoritmo (por qué no da [TLE](https://www.geeksforgeeks.org/overcome-time-limit-exceedtle/)?)
    * Si es que agregaste un link a tu solución en código
      * la calidad de este código (si está ordenado, si está razonablemente comentado)
      * **Si tu código está en C++ (preferiblemente C++11)**. Sabemos que la mayoría se siente más comoda programando en Python, por lo que programar en C++ requiere (al menos al principio) un esfuerzo adicional. Aquellas personas que escriban su código en C++ y lo compartan al final de su explicación tendrán más décimas, como recompensa a su esfuerzo ([tips para programar en C++/C++11](#tips-para-implementación-con-c))
  
* __BONUS RPC__ (grupal): Cada cierto tiempo la [Red de Programación Competitiva (RPC)](http://redprogramacioncompetitiva.com/) organiza competencias de entrenamiento. El calendario y registro para estas competencias se encuentran acá: http://registro.redprogramacioncompetitiva.com/contests, y los scoreboards de las competencias pasadas se pueden encontrar acá: http://redprogramacioncompetitiva.com/Contest. Nótese que se trata de un **bonus grupal**, por ende para obtener este bonus deben:
  * Registrarse en una competencia en grupos de 2 o 3 alumn@s.
  * Participar en la competencia
  * Mandar una foto del grupo con todos sus integrantes juntos frente a un mismo computador (sí, la idea es que se junten físicamente usando un solo computador, [como en este ejemplo](https://youtu.be/BZo23gj9ksk?t=4237)).
  * Al terminar la competencia, deben mandar el link al scoreboard final de la competencia RPC en que participaron.
  * El bonus se calculará como 6 * (X/N) décimas, donde X = problemas resueltos por el grupo, N = problemas resueltos por el equipo que quedó en primer lugar. Las 6 * (X/N) décimas obtenidas se sumarán directamente a su nota final.

* __BONUS Codeforces__ (individual): Cada cierto tiempo [Codeforces](http://codeforces.com/) organiza competencias individuales, que generalmente duran alrededor de 2 horas, con problemas de diferentes niveles de dificultad. Si se registran en Codeforces, el sitio les debería ir avisando por email sobre las próximas competencias. O bien, pueden revisar el [siguiente calendario](http://codeforces.com/calendar). Para obtener este bonus deben:
  * Registrarse en Codeforces.
  * Participar en una competencia.
  * Al final de la competencia avisarnos en qué competencia participaron (por ej. mandar el link a su perfil de Codeforces).
  * El bonus se calculará como 4 * (X/N) décimas, donde X = problemas resueltos por el alumno, N = problemas resueltos por la persona que quedó en primer lugar. Las 4 * (X/N) décimas obtenidas se sumarán directamente a su nota final.

# Cálculo de la Nota Final
La nota final del curso se calculará de la siguiente manera:
* Sea X_temprano = cantidad total de puntos por problemas resueltos entre las 15:30 y las 23:59
* Sea X_tarde = cantidad total de puntos por problemas resueltos pasadas las 23:59
* Sea X_repechaje = cantidad total de puntos por problemas en el contest de repechaje
* Luego, se obtiene X_final = X_temprano + 0.8 * X_tarde + 0.5 * X_repechaje
* Sea E = cantidad mínima de puntos esperados al final del semestre
* Así, se obtiene una nota preliminar
   * Nota_v1 = 1 + 6 * min(X_final/E, 1)
* Sin embargo, luego se bajará la escala del curso, es decir, si ningún alumno alcanzó el 7, el alumno con mayor nota quedará con 7 (siempre y cuando la escala baje "poco" - i.e. habrá un límite para bajar la escala con el fin de desincentivar posibles conspiraciones).
   * Nota_v2 = aplicar_escala_reducida(Nota_v1)
* Finalmente, se aplicarán las décimas de bonus:
   * Nota_v3 = Nota_v2 + BONUS EXPLICACIÓN PROBLEMA + BONUS RPC + BONUS Codeforces
* Todo lo anterior se encuentra formalizado en el [spreadsheet de notas y asistencia](https://docs.google.com/spreadsheets/d/13NJgv8usjIq8LeWcR_ctjFQHK_Wm9TejJNGIuKvI0Gc/edit?usp=sharing)

# Temario tentativo del Semestre

Individual
* Implementación, Fuerza Bruta, Backtracking (3 semanas)
* Binary Search (2 semanas)
* DP básico (2 semanas)
* Algoritmos Greedy (1 semana)
* Grafos básico (3 semanas)
* Matemática (3 semanas)
* Geometría básica (1 semana)

Grupal
* Tutifruti (de todo, resto del semestre)

# Estoy pegad@, no sé resolver un problema, no se me ocurre, no sé implementarlo, ¿qué puedo hacer?
En programación competitiva es normal encontrarse con problemas fuera de nuestra zona de comfort, problemas que nos superan, que nos frustran y que inclusive llegan hasta deprimirnos. Problemas que nos hacen decir ["Oh, y ahora quién podrá .. ayudarme?"](https://www.youtube.com/watch?v=VQAonx_tUjM). Para esos programadores y programadoras desamparad@s hay buenas noticias: ¡existen muchas formas de recibir ayuda!

Primero que todo, están los talleres presenciales (3 módulos los días viernes). Tanto el profesor como el ayudante estaremos físicamente ahí presentes para que nos bombardeen con preguntas. Tanto código como teoría, lo que sea. No tengan miedo, pregunten. Del mismo modo, también están sus compañer@s. En un curso siempre hay alumn@s más experimentad@s que sobresalen. Aprovechenl@s y háganles preguntas. Conversen. No es necesario estar toda la clase callad@ sin interactuar con nadie. La idea es que aprovechen la instancia presencial para discutir sobre los problemas con sus compañer@s y con el staff del curso.

Sin embargo, sabemos que la timidez es un problema y no tod@s se sienten cómod@s preguntando en persona, por lo cual también existen alternativas de ayuda remota:
 * **Telegram**. Pueden hacer preguntas en el grupo de Telegram del curso. Si necesitan una ayuda más personalizada, Telegram también permite chatear directamente con personas (1 a 1), ya sea con el profesor, el ayudante o incluso con sus otros compañer@s más experimentad@s (por Telegram se puede mandar hasta archivos e incluso screenshots de códigos).
 * **Google Docs con explicaciones**. como sale explicado más arriba en el [apartado sobre bonuses](#3-bonuses), existe un bonus para ganar décimas que consiste en explicar soluciones de problemas (por favor leer el [apartado sobre bonuses](#3-bonuses) para más detalles). Si bien es un bonus, la idea es que a la vez sirva como un medio solidario para la difusión del conocimiento. Aprovechen estos google docs para enriquecerse con la sabiduría de los demás ([éticamente](#reglas-ética), por supuesto) y a la vez para compartir su sabiduría con el resto.
 * **La página del curso** (i.e. este archivo que estás leyendo ahora), y en general, **internet**: Si te gusta más estudiar por cuenta propia, más abajo en esta página encontrarás mucho material de estudio disponible sobre distintos temas. Aconsejamos ir consultando estos recursos a medida que vayamos viendo estos temas en el taller. Por supuesto, también está disponible internet. Pero de nuevo, por favor hagan un uso [ético](#reglas-ética) de estos recursos.


# Reglas (Ética)
Puedes hacer uso de recursos en línea al resolver problemas. Esto incluye documentación de tu lenguaje de programación, descripciones de algoritmos, implementaciones estándar de ciertos algoritmos y estructuras de datos como referencia, wikipedia, youtube, libros, tutoriales, etc. En caso de **desesperación**, está incluso permitido consultar soluciones de ejemplo. Sin embargo, **LA COPIA DESCARADA DE SOLUCIONES AJENAS** está terminantemente **PROHIBIDA**. Para evitar esto, nuestra recomendación al enfrentar problemas es la siguiente:

1) Primero intenta resolver los problemas por ti mism@, trata de no usar ningún recurso externo excepto por quizá documentación del lenguaje de programación que estás usando (por ej. si es que se te olvidó cómo se usaba cierta cosa de la librería estándar)
2) Si un problema está muy difícil, intenta cambiarte a otro problema más fácil (puedes ver los problemas más resueltos en el scoreboard, probablemente son los más fáciles).
3) Eventualmente si llegas a un punto en que te sientes pegad@ con todos los problemas que quedan, entonces es tiempo de pedir ayuda. Durante la clase te invitamos a discutir los problemas con otros compañer@s o con el staff. Fuera de la clase, puedes leer las explicaciones que vayamos subiendo a los google docs o bien puedes hacer preguntas en el Telegram del curso.
4) Si lo anterior no es suficiente, puedes googlear explicaciones teóricas (palabras) en internet. También puedes consultar material de estudio, códigos de estructuras de datos y algoritmos estándar, etc. Si haces esto, por favor **incluye las referencias (links) en tu código**, explicando qué fuentes consultaste y en qué te ayudaron.
5) Si las explicaciones teóricas y recursos estándar de referencia no son suficientes, como medida de **desesperación** y **último recurso** te está éticamente permitido mirar soluciones ajenas de ejemplo. Sin embargo, **por ningún motivo hagas copy-paste**. Lo que debes hacer es tratar de entender el código y sacar ideas a partir de él que te permitan programar tu propia solución. El objetivo es que aprendas. Si haces copy-paste, ¿estarás aprendiendo algo?
6) Finalmente, ten presente que vjudge.net le otorga al autor de un contest acceso a las soluciones de los participantes ... Sí, podemos ver tu código :). Si alguien [misteriosamente](https://youtu.be/HQoRXhS7vlU) resuelve un problema difícil, tenga la seguridad de que con probabilidad muy alta su código será examinado.

Si llegamos a descubrir una copia, el  **castigo consistirá en lo siguiente**:
1) Primera copia: nota_final = max(min(nota_v3, 7) - 3, 1)
2) Segunda copia: nota_final = 1 + causal de eliminación

# Comentarios Adicionales

### Sobre lenguajes de programación
En programación competitiva el lenguaje más utilizado por lejos es C++ (y dentro de C++ generalmente se usa de C++11 para arriba). En segundo lugar se encuentra Java. [Y hace muy poco se comenzó a utilizar también Python](https://www.quora.com/Can-Python-be-used-in-ACM-ICPC). Sin embargo, lamentablemente la mayoría de los jueces online (los servidores que tienen los enunciados de los problemas y ejecutan los códigos enviados por la gente) están calibrados generalmente para aceptar soluciones en C++, y a veces pasa que las soluciones en Python fallan con el famoso [Time Limit Exceeded (TLE)](https://www.geeksforgeeks.org/overcome-time-limit-exceedtle/), debido a que Python por ser un lenguaje interpretado se ejecuta más lento que lenguajes compilados a código de máquina como C++. Además, la mayoría de los códigos de ejemplo disponibles en internet para progcomp están en C++ o quizá Java. Por este motivo, el consejo típico es aprender C++. Si te motivas a seguir este consejo, más abajo puedes encontrar [material introductorio para aprender C++](#para-aprender-c-muy-recomendado) y [tips de implementación en C++ para progcomp](#tips-para-implementación-con-c). Dicho esto, que esto por favor no se malinterprete como que usar C++ es una obligación. No, no. Si ustedes quieren, pueden usar Python, no hay ningún problema. De hecho en muchos problemas las restricciones de tiempo son suficientemente holgadas y usar Python es perfectamente válido. El objetivo de este comentario es simplemente hacerles concientes de que al usar Python existe cierto riesgo de TLE por jueces "pesados" con restricciones de tiempo muy estrictas, y también que C++ es por lejos el lenguaje más popular en programación competitiva. Si deciden aprender C++, nuestro consejo es que vayan aprendiendo el lenguaje poco a poco, sin estresarse. Por ejemplo pueden ir intercalando entre C++ y Python. O pueden programar una solución en Python y después traducirla a C++, etc. Además siempre estaremos subiendo ejemplos de soluciones en C++, y tanto el profesor como el ayudante estaremos a su servicio para que nos hagan todas las consultas que quieran.

### Sobre restricciones de tiempo y memoria en programación competitiva
 - En la ICPC y en la mayoría de los jueces online de entrenamiento los problemas tienen límites de tiempo (ej. 3 segundos) y memoria (ej. 256 MB). Esto significa que soluciones muy lentas o soluciones que requieren anotar demasiadas cosas **no funcionarán**.
 - En C++, pueden hacerse un poco más de **10^8 operaciones baratas por segundo** (una estimación bien al ojo por experiencia con diferentes jueces online). Por lo tanto, si les dan K segundos de tiempo límite, a lo más podrán hacer un poco más de K * 10^8 operaciones baratas. Tengan esto muy presente.
 - **MUY IMPORTANTE**: **ANTES DE TOCAR EL TECLADO, ANTES DE ESCRIBIR LA PRIMERA LÍNEA DE CÓDIGO**, es sumamente importante estimar cuánto se va a demorar la estrategia/algoritmo que quiero programar. Nadie quiere desperdiciar su tiempo programando una solución que después es muy lenta y nos da TLE (Time Limit Exceeded). Es por esto que **siempre deben estimar la [complejidad computacional](https://en.wikipedia.org/wiki/Time_complexity)** de su algoritmo y **evaluarla en el caso borde más grande** (peor caso). Por ejemplo, si un problema depende de N donde 1 <= N <= 10^5 y mi algoritmo es cuadrático (complejidad = O(N^2)), entonces en el peor caso haré (10^5)^2 = 10^10 operaciones, y por ende según el punto anterior necesitaría **100 segundos** para correrlo. En cambio, si mi algoritmo tiene complejidad O(N\*log(N)) entonces en el peor caso sólo haré 10^5 * log(10^5) = 1.7 * 10^6 operaciones (aprox.), y por ende sólo necesitaría **0.017 segundos** (la nada misma) para correrlo. Entonces, si mi problema tiene un tiempo máximo de ejecución de 2 segundos, ¿qué algoritmo va a funcionar? Claramente el segundo.
 - Si van a usar mucha memoria, preocúpense de **no pasarse del límite de memoria permitido**. Por ejemplo si les dan 256MB de memoria, en bytes eso es 256 * 1024 * 1024 = 268435456 bytes, un int32 ocupa 4 bytes, así que como máximo podrían crear un arreglo de int32 de largo 67108864 = 6.7 * 10^7 aprox (o la mitad si usan un int64, un double, etc.). También podría acabárseles la memoria si hacen demasiadas llamadas recursivas [[1](https://codeforces.com/blog/entry/47003), [2](https://stackoverflow.com/a/11777585/2801404)].
 
### Mensaje para Alumnos Nuevos

Tranquil@s. Que no cunda el pánico. El curso puede parecer a primera vista intimidante pero realmente no es así. Primero que todo, este es un curso de 5 créditos, así que la carga de trabajo semanal será acorde a un curso de 5 créditos. En la práctica esto significa que si trabajan a conciencia, el mismo día viernes debiesen alcanzar a hacer todo o al menos la mayoría del trabajo mínimo exigido de la semana. En segundo lugar, con respecto a lenguajes de programación, hemos notado que muchos se sienten intimidados ante la posibilidad de tener que aprender C++. Queremos recordarles que usar C++ es **recomendado** pero **no es obligatorio**. Si lo desean, pueden usar Python y es perfectamente válido. Para más detalles, por favor leer el [comentario sobre lenguajes de programación](#sobre-lenguajes-de-programaci%C3%B3n). En tercer lugar, en este curso nunca les pediremos que resuelvan problemas demasiado difíciles para su nivel. Siempre nos preocupamos de incluir problemas con un nivel de dificultad asequible para los novatos. Y por último, [recuerden que siempre pueden contar con nuestra ayuda](#estoy-pegad-no-sé-resolver-un-problema-no-se-me-ocurre-no-sé-implementarlo-qué-puedo-hacer).


_________________________________

# Recursos para Consultar

### General
* Canales de Youtube con muchas explicaciones:
  * Gaurav Sen: https://www.youtube.com/channel/UCRPMAqdtSgd0Ipeef7iFsKw
  * WillianFiset: https://www.youtube.com/channel/UCD8yeTczadqdARzQUp29PJw
  * Abdul Bari: https://www.youtube.com/channel/UCZCFT11CWBi3MHNlGf019nw
  * Algorithms Live!: https://www.youtube.com/channel/UCBLr7ISa_YDy5qeATupf26w/
  * Tushar Roy - Coding Made Simple: https://www.youtube.com/channel/UCZLJf_R2sWyUtXSKiKlyvAw
  * Programación Competitiva CL:  https://www.youtube.com/channel/UCmVg7YyMS8H-65WCmkVHB9g/feed
* Repositorios con muchos códigos de ejemplo (implementaciones de algoritmos y estructuras de datos típicos):
  * Team Notebook (muy bueno y completo): [link](https://github.com/pin3da/Programming-contest/blob/master/codes/notebook.pdf)
  * C++ Cheat Sheet for ACM ICPC : https://github.com/ntuorangejuice/cheat-sheet
  * Stanford University ICPC Team Notebook: https://cs.stanford.edu/group/acm/SLPC/notebook.pdf
  * Google Doc con muchos códigos (C++): https://docs.google.com/document/d/1rcex_saP4tExbbU62qGUjR3eenxOh-50i9Y45WtHkc4/edit
  * Google Doc con Apuntes de Robinson Castro et al (C++): https://docs.google.com/document/d/1pan53PU9_PIrPPVyNrbfXIAU-B6YnIaSBcB9lP9j0jE/edit  
  * Repo de Apuntes del team Caloventor en Dos (C++): https://github.com/mvpossum/eldiego
  * Repo de Apuntes de Pablo Messina (C++): https://github.com/PabloMessina/Competitive-Programming-Material
* Otras páginas con links a muchos recursos y material de estudio:
  * CP-ALGORITHMS: https://cp-algorithms.com/
  * Codeforces: An awesome list for competitive programming!: https://codeforces.com/blog/entry/23054
     * All of the good tutorials found on codeforces: https://codeforces.com/blog/entry/57282
  * Standford CS 97SI: Introduction to Programming Contests: http://web.stanford.edu/class/cs97si/
  * GeeksForGeeks: HOW TO PREPARE FOR ACM ICPC: https://www.geeksforgeeks.org/how-to-prepare-for-acm-icpc/
  * GeeksForGeeks: Top 10 Algorithms and Data Structures for Competitive Programming: https://www.geeksforgeeks.org/top-algorithms-and-data-structures-for-competitive-programming/
  * Sitio web del Taller de la U. de Chile: http://progcomp.cl/taller
  * Techie Delight: Coding made easy: http://www.techiedelight.com/  
  * Material Campamento 2015 progcomp.cl: http://campamento2015.progcomp.cl/material
  * Material Campamento 2016 progcomp.cl: http://campamento2016.progcomp.cl/material
  * Material Campamento 2017 progcomp.cl: http://campamento2017.progcomp.cl/material
  * Material Campamento 2018 progcomp.cl: http://campamento2018.progcomp.cl/material
* Libros con harto material de programación competitiva:
  * Competitive Programmer's Handbook: https://www.cses.fi/book.pdf
  * Competitive Programming 2: https://www.scribd.com/doc/155208844/Competitive-Programming-2
  * Competitive Programming 3 (CP3): https://cpbook.net/

### Soluciones de Regionales Latinoamericanas
* Blogs con explicaciones:
  * Blog CaloventorEnDos: http://caloventorendos.blogspot.cl
  * Chocoblog: https://chococontest.wordpress.com/
  * [Codeforces - ACM ICPC 2011 Latin America Finals](https://codeforces.com/blog/entry/3452)
  * [Codeforces - ACM ICPC 2012 Latin America Finals](https://codeforces.com/blog/entry/5809)
  * [Codeforces - ACM ICPC 2014 Latin America Finals](https://codeforces.com/blog/entry/14650)
  * [Codeforces - ACM ICPC 2015 Latin America Finals](https://codeforces.com/blog/entry/21576)
  * [Codeforces - ACM ICPC 2016 Latin America Finals](https://codeforces.com/blog/entry/48366)
  * [Codeforces - ACM ICPC 2017 Latin America Finals](https://codeforces.com/blog/entry/55700)
  * [Codeforces - ACM ICPC 2018 Latin America Finals](https://codeforces.com/blog/entry/63157)
* Google Sheet con soluciones de las últimas regionales (work in progress): https://docs.google.com/spreadsheets/d/1F8aBV83xKPVFfq_A0EKhCa8qbjf0gKKg8puQF-rbonQ/
* Inputs y outputs oficiales de regionales latam pasadas: http://maratona.ime.usp.br/antigas18.html

### Soluciones, Inputs y Outputs oficiales de Regionales Norteamericanas
* http://acmgnyr.org
* http://cs.ecs.baylor.edu/~hamerly/icpc/

### Para aprender C++ (MUY RECOMENDADO)
 * INPUT / OUTPUT:
   * Yet again on C++ input/output: http://codeforces.com/blog/entry/5217
   * ¿Qué es mejor para leer input / imprimir output? cin/cout vs printf/scanf: http://www.cplusplus.com/forum/beginner/34165/
 * Documentación Oficial de C++: http://www.cplusplus.com/reference/ 
 * C++ Tutorial (SOLO LEARN: EVERYONE CAN CODE): https://www.sololearn.com/Course/CPlusPlus/
 * LearnCpp: http://www.learncpp.com/
 * Intro a C++: https://youtu.be/pqWsOsfGKA0
 * Intro a la Programación Competitiva en C++: https://youtu.be/zTUJFG34Tyw
 * Estructuras básicas en C++: https://youtu.be/OldL5e5eGmY
 * C++ Programming Video Tutorials For Beginners [ Complete Series ]: https://www.youtube.com/playlist?list=PLfVsf4Bjg79Cu5MYkyJ-u4SyQmMhFeC1C 
 * C++ Cheat Sheets & Tricks:
   * C++ Cheat Sheet for ACM ICPC : https://github.com/ntuorangejuice/cheat-sheet
     * Aquí pueden encontrar un C++ Solution Template (código que uno siempre escribe al comenzar una solución) + MUCHO MUCHO más :)
   * C++ STL cheatsheet for competitive programming: https://gist.github.com/satwikkansal/c959e89161cc60db16b412233177feab
   * C++ Tricks: https://codeforces.com/blog/entry/15643
   * C++ tricks for competitive programming (for C++ 11): https://www.geeksforgeeks.org/c-tricks-competitive-programming-c-11/
   * C++ Cheat Sheet de Pablo Messina: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/c%2B%2B_cheat_sheet.cpp
 * Instalando y corriendo C++:
   * Windows:
     * http://www.mingw.org/Welcome_to_MinGW_org
     * https://www.quora.com/How-do-I-compile-a-C++-program-on-a-Windows-PC-in-CMD
   * Ubuntu:
     * http://askubuntu.com/questions/348654/how-to-install-g-compiler
     * http://askubuntu.com/questions/61408/what-is-a-command-to-compile-and-run-c-programs
   * Mac:
     * https://www.quora.com/What-is-the-best-FREE-C-C++-compiler-for-Mac-OS
     * http://stackoverflow.com/questions/9148488/how-do-i-compile-c-with-clang
 * Ejemplo de secuencia de pasos para resolver un problema en C++ en Windows usando la terminal (en Linux/Mac es bien parecido):
    * Crear un archivo example.cpp
    * Escribir un código de C++ válido y guardar.
    * Abrir una terminal y navegar a la carpeta donde está el archivo.
    * Opción 1:
      * En la terminal, compilar y ejecutar con el comando: ```g++ -std=c++11 example.cpp && a.exe```
      * Escribir el input directamente en la terminal
      * El output irá apareciendo poco a poco en la terminal (intercalado con el input)
    * Opción 2:      
      * Crear un archivo en la carpeta donde están parados llamado input.txt, copiar y pegar el input ahí y guardar.
      * En la terminal, compilar y ejecutar con el comando: ```g++ -std=c++11 example.cpp && a.exe < input.txt```
      * el output aparecerá en la misma terminal
    * Opción 3:
      * Crear un archivo en la carpeta donde están parados llamado input.txt, copiar y pegar el input ahí y guardar.
      * En la terminal, compilar y ejecutar con el comando: ```g++ -std=c++11 example.cpp && a.exe < input.txt > output.txt```
      * el output quedará guardado en el archivo output.txt

___________________________________________
## Material para Temas Específicos

### Tricks para problemas Ad-Hoc:
 * General Ideas: https://codeforces.com/blog/entry/48417
 
### Tips para implementación con C++
* Cosas útiles que deberían saber de **C++11** (<<<< **PARA ESCRIBIR CÓDIGOS MÁS CORTOS Y ELEGANTES**):
  * Tutorial: C++11 for programming contests: https://codeforces.com/blog/entry/10124
  * Learn C++ 11 in 20 Minutes - Part I: https://youtu.be/U6mgsPqV32A
  * Learn C++ 11 in 20 Minutes - Part II: https://youtu.be/Lt0ASrloGSE
* [Codeforces - Manejo de Strings en C++](https://codeforces.com/blog/entry/6230) (<<< **buenos tips para cuando tienen que leer input**)
* [Youtube playlist: lista exhaustiva de videos cubriendo muchísimos aspectos de C++](https://www.youtube.com/playlist?list=PLfVsf4Bjg79Cu5MYkyJ-u4SyQmMhFeC1C)
* Los beneficios de usar references (&) y pointers (*):
   * [geeksforgeeks - Passing vector to a function in C++](https://www.geeksforgeeks.org/passing-vector-function-cpp/)
   * [geeksforgeeks - When do we pass arguments by reference or pointer?](https://www.geeksforgeeks.org/when-do-we-pass-arguments-by-reference-or-pointer/)   
   * [Diferencia entre references y pointers explicada](http://www.ntu.edu.sg/home/ehchua/programming/cpp/cp4_pointerreference.html)
* STL: standard template library (<<< buen material sobre la standard library de C++, **MUY RECOMENDADO**)
  * Introduction of STL #1: Overview: https://youtu.be/ltBdTiRgSaw
  * Introduction of STL #2: Sequence Containers: https://youtu.be/gxZJ5JNuWMY
  * Introduction of STL #3: Associative Containers: https://youtu.be/6iyzPed7FrM
  * Introduction of STL #4: Unordered Containers: https://youtu.be/NNLvY9O7ufU
  * Introduction of STL #5: Iterators and Algorithms: https://youtu.be/vO2AlrBf5rQ
  * Introduction of STL #6: Functors: https://youtu.be/shqvSkk8r0M
  * [Topcoder: power up c++ with the standard template library part 1](https://www.topcoder.com/community/competitive-programming/tutorials/power-up-c-with-the-standard-template-library-part-1/)
  * [Topcoder: power up c++ with the standard template library part 2](https://www.topcoder.com/community/competitive-programming/tutorials/power-up-c-with-the-standard-template-library-part-2/)
  * [Youtube playlist: varios algoritmos de la librería estándar de C++ para llegar y usar](https://www.youtube.com/playlist?list=PLVFrD1dmDdve4h3Shk0uePpXp8JUMM1w5)
* Para aprender a trabajar con bits:
  * [HackerRank - Algorithms: Bit Manipulation](https://youtu.be/NLKQEOgBAnw)
  * [Tutorial sobre Bitwise Operators](https://www.cprogramming.com/tutorial/bitwise_operators.html)
  * [¿Qué es bit masking?](https://stackoverflow.com/questions/10493411/what-is-bit-masking)
  * [geeksforgeeks - Bitwise hacks for competitive programming](https://www.geeksforgeeks.org/bitwise-hacks-for-competitive-programming/)
  * [geeksforgeeks - Bit Tricks for competitive programming](https://www.geeksforgeeks.org/bit-tricks-competitive-programming/)
* ¿Qué son y para qué sirven **Structs** y **Classes** en C++?
  * Advanced C++: Struct Vs. Class: https://youtu.be/qJ4Kzk6mnFc
  * Introduction to Structures in C++ | CPP Programming Video Tutorial: https://youtu.be/6gg9Xlv35-I
  * Buckys C++ Programming Tutorials - 12 - Introduction to Classes and Objects: https://youtu.be/ABRP_5RYhqU
  * Structure and Class differences in C++ | C ++ Tutorial | Mr. Kishore: https://youtu.be/W1f3TelobMg
  * CLASSES vs STRUCTS in C++: https://youtu.be/fLgTtaqqJp0

### Backtracking
* https://progcomp.cl/backtracking
* 6 Introduction to Backtracking - Brute Force Approach: https://www.youtube.com/watch?v=DKCbsiDBN6c
* 6.1 N Queens Problem using Backtracking: https://www.youtube.com/watch?v=xFv_Hl4B83A
* 6.2 Sum Of Subsets Problem - Backtracking: https://www.youtube.com/watch?v=kyLxTdsT8ws
* 6.3 Graph Coloring Problem - Backtracking: https://www.youtube.com/watch?v=052VkKhIaQ4
* Algorítmia - Tema 5. Backtracking. N-Reinas - Andrés Muñoz Ortega: https://www.youtube.com/watch?v=XQYGwKiqV3Y

### Search:
* Binary Search:
  * [Youtube - Excelente video explicando binary search (**RECOMENDADO**)](https://www.youtube.com/watch?v=jf1baieXkSQ) 
  * [Youtube - muy buena comparación entre linear search y binary search (+ código)](https://www.youtube.com/watch?v=wNVCJj642n4)
  * [Youtube - Algorithms: Binary Search](https://youtu.be/P3YID7liBug)
  * http://progcomp.cl/binarysearch
  * [Ejemplo de implementación en C++](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Search/BinarySearch.cpp)  
  * [geeksforgeeks - Binary Search functions in C++ STL (binary_search, lower_bound and upper_bound)](https://www.geeksforgeeks.org/binary-search-functions-in-c-stl-binary_search-lower_bound-and-upper_bound/)
  * caso especial: [binary search on doubles - codeforces](http://codeforces.com/blog/entry/20390) **cuando el problema es continuo (no-discreto)**
* Ternary Search:
  * https://www.hackerearth.com/practice/algorithms/searching/ternary-search/tutorial/
  * https://en.wikipedia.org/wiki/Ternary_search
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Search/TernarySearch.cpp
  * **Cómo reducir Ternary Search a Binary Search**: [Codeforces - The great ternary search hoax](http://codeforces.com/blog/entry/11497)

### Dynamic Programming (DP):
* ¿Qué es DP?
  * [What Is Dynamic Programming and How To Use It](https://www.youtube.com/watch?v=vYquumk4nWw) **<<<<< MUY BUEN VIDEO, VÉANLO!**
  * [Principle of Optimality - Dynamic Programming introduction](https://www.youtube.com/watch?v=5dRGRueKU3M)  
  * [Algorithms: Memoization and Dynamic Programming](https://www.youtube.com/watch?v=P8Xa2BitN3I)
  * [19. Dynamic Programming I: Fibonacci, Shortest Paths](https://www.youtube.com/watch?v=OQ5jsbhAv_M)
* Dos formas generales de usar DP: Bottom-Up vs Top-Down:
  * http://stackoverflow.com/questions/6164629/dynamic-programming-and-memoization-bottom-up-vs-top-down-approaches
* Ejemplos de **problemas concretos** donde se puede usar DP:
  * Coin Change: [link](https://youtu.be/jaNZ83Q3QGc)
  * Matrix Chain Multiplication: [link1](https://youtu.be/prx1psByp7U), [link2](https://youtu.be/eKkXU3uu2zk)
  * Longest Increasing Subsequence (LIS): [video](https://youtu.be/fV-TF4OvZpk), [explicación stackoverflow](https://stackoverflow.com/questions/2631726/how-to-determine-the-longest-increasing-subsequence-using-dynamic-programming)
  * Knapsack problem: [link](https://youtu.be/nLmhmB6NzcM)
  * Traveling Salesman Problem (TSP): [video](https://youtu.be/XaXsJJh-Q5Y), [implementación usando bitmasks](https://www.geeksforgeeks.org/bitmasking-dynamic-programming-set-2-tsp/)
  * Minimum Edit Distance Between 2 Strings - The Levenshtein Distance: [link1](https://youtu.be/Xxx0b7djCrs), [link2](https://youtu.be/MiqoA-yF-0M)
  * Otros ejemplos: [playlist](https://www.youtube.com/watch?v=8LusJS5-AGo&list=PLrmLmBdmIlpsHaNTPP_jHHDx_os9ItYXr)
* Optimizaciones para DP: 
  * Divide & Conquer Optimization:
    * http://jeffrey-xiao.github.io/#!/blog/posts/2015-12-14-Divide-and-Conquer-Optimization
    * https://www.hackerrank.com/contests/ioi-2014-practice-contest-2/challenges/guardians-lunatics-ioi14/editorial
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Dynamic_Programming/Divide%26ConquerOptimization.cpp     * https://www.youtube.com/watch?v=wLXEWuDWnzI
    
### Greedy:
* https://www.geeksforgeeks.org/greedy-algorithms/
* https://brilliant.org/wiki/greedy-algorithm/
* https://en.wikipedia.org/wiki/Greedy_algorithm
   
### Graphs:
* Slides de Nico Lehmann sobre Grafos:
  * http://campamento2015.progcomp.cl/material (revisar la parte Grafos)
  * http://campamento2016.progcomp.cl/material (revisar la parte Grafos)  
* Trees (Árboles): https://en.wikipedia.org/wiki/Tree_(graph_theory)
* Play list sobre Grafos: https://www.youtube.com/playlist?list=PLrmLmBdmIlpu2f2g8ltqaaCZiq6GJvl1j
* Breadth First Search (BFS) & Depth First Search (DFS):
  * [5.1 Graph Traversals - BFS & DFS -Breadth First Search and Depth First Search](https://www.youtube.com/watch?v=pcKY4hjDrxk)
  * [Graph Traversals - Breadth First and Depth First](https://www.youtube.com/watch?v=bIA8HEEUxZI)
  * [Graph : BFS, DFS](https://www.youtube.com/watch?v=ImMnYq2zP4Y)
  * [Algorithms: Graph Search, DFS and BFS](https://www.youtube.com/watch?v=zaBhtODEL0w)
  * Códigos de ejemplo: [DFS](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/DFS.cpp) Y [BFS](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/BFS.cpp)
* Flood Fill: https://en.wikipedia.org/wiki/Flood_fill
* Topological Sort:
  * [Topological Sort Algorithm | Graph Theory](https://www.youtube.com/watch?v=eL-KzMXSXXI)
  * [Topological Sort Graph Algorithm](https://www.youtube.com/watch?v=ddTC4Zovtbc)
  * [Códigos de ejemplo](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/TopoSort.cpp)
  * [Codeforces - How to check cycles inside a Topological Sort](https://codeforces.com/blog/entry/4907)
* Shortest Paths Algorithms:
  * De un nodo (**single source**) a todos los demás nodos:
    * Dijkstra (cuando NO hay aristas negativas):
      * [Dijkstra's algorithm in 3 minutes — Review and example](https://www.youtube.com/watch?v=_lHSawdgXpI)
      * [Dijkstra's Algorithm (5 minutos)](https://www.youtube.com/watch?v=gdmfOwyQlcI)
      * [Muy buen ejemplo de Dijkstra](https://www.youtube.com/watch?v=5GT5hYzjNoo)
      * [Correctness of Dijkstra's Algorithm](https://www.youtube.com/watch?v=ZjSvU2guTtY)
      * [cp-algorithms: dijkstra (incluye código de ejemplo)](https://cp-algorithms.com/graph/dijkstra.html)
      * [Código de ejemplo](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/Dijkstra.cpp)
      * [Código de ejemplo Ignacio](https://github.com/ignaciohermosillacornejo/apuntes_icpc/blob/master/graphs/dijsktra/dijsktra.cpp)
    * Bellman-Ford (cuando SÍ hay aristas negativas):
      * [Bellman-Ford in 5 minutes — Step by step example](https://www.youtube.com/watch?v=obWXjtg0L64)
      * [Bellman-Ford in 4 minutes — Theory](https://www.youtube.com/watch?v=9PHkk0UavIM)
      * [Bellman-Ford Algorithm: Proof of Correctness](https://es.coursera.org/lecture/algorithms-on-graphs/bellman-ford-algorithm-proof-of-correctness-txk8R)
      * [Bellman Ford Algorithm - Single Source Shortest Path - Dynamic Programming (17m)](https://www.youtube.com/watch?v=FtN3BYH2Zes)
      * [cp-algorithms: bellman-ford (incluye códigos de ejemplo)](https://cp-algorithms.com/graph/bellman_ford.html)
      * [Código de ejemplo](https://github.com/ignaciohermosillacornejo/apuntes_icpc/blob/master/graphs/bellmanFord/bellmanFord.cpp)
      * ¿Cómo detectar un ciclo negativo con Bellman-Ford?
        * [GeeksforGeeks - Detect a negative cycle in a Graph | (Bellman Ford)](https://www.geeksforgeeks.org/detect-negative-cycle-graph-bellman-ford/)
        * [Proof of Correctness](https://web.stanford.edu/class/archive/cs/cs161/cs161.1168/lecture14.pdf)
  * De todos los nodos (**multiple source**) a todos los nodos:
    * Floyd-Warshall
      * [Floyd–Warshall algorithm in 4 minutes](https://www.youtube.com/watch?v=4OQeCuLYj-4)
      * [All Pairs Shortest Path (Floyd-Warshall) - Dynamic Programming (14m)](https://www.youtube.com/watch?v=oNI0rf2P9gE)
      * [cp-algorithms: floyd-warshall (incluye código de ejemplo)](https://cp-algorithms.com/graph/all-pair-shortest-path-floyd-warshall.html)
      * [Código de ejemplo](https://github.com/ignaciohermosillacornejo/apuntes_icpc/blob/master/graphs/floydWarshall/floydWarshall.cpp)
      * ¿Qué pasa cuando hay ciclos negativos?
        * [Behavior_with_negative_cycles (wikipedia)](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm#Behavior_with_negative_cycles)
        * [Floyd-Warshall with negative cycles. How do I find all undefined paths?](https://stackoverflow.com/questions/15709277/floyd-warshall-with-negative-cycles-how-do-i-find-all-undefined-paths)
      
* Articulation Points (aka Cut Vertices), Bridges (aka Cut Edges) and Biconnected Components (aka Blocks): 
  * Graph Theory: 53. Cut-Vertices: https://www.youtube.com/watch?v=BxAgmaLWaq4
  * Graph Theory: 55. Bridges and Blocks: https://www.youtube.com/watch?v=iGsxKUzW3cs
  * Menger's Theorem: https://www.youtube.com/watch?v=dUAeleBMRCQ
    * https://www.quora.com/How-can-I-prove-without-using-Mengers-theorem-that-any-two-vertices-of-a-2-connected-graph-lie-on-a-common-cycle
  * Articulation Points Graph Algorithm: https://www.youtube.com/watch?v=2kREIkF9UAs
  * http://web.iitd.ac.in/~bspanda/biconnectedMTL776.pdf
  * https://www.hackerearth.com/practice/algorithms/graphs/articulation-points-and-bridges/tutorial/
  * https://www.hackerearth.com/practice/algorithms/graphs/biconnected-components/tutorial/
  * Código de ejemplo: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/articulation-points%2Ccut-edges%2Cbiconnected-components.cpp
* Diameter of a Tree:
  * http://cs.stackexchange.com/questions/22855/algorithm-to-find-diameter-of-a-tree-using-bfs-dfs-why-does-it-work
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/diameter_of_tree.cpp
* Minimum Spanning Tree:
  * Kruskal's Algorithm:
    * https://www.youtube.com/watch?v=71UQH7Pr9kU
    * https://www.youtube.com/watch?v=fAuF0EuZVCk
  * Prim's Algorithm:
    * https://www.youtube.com/watch?v=cplfcGZmX7I
    * https://www.youtube.com/watch?v=oP2-8ysT3QQ
  * Correcteness Proofs:
    * Proof of Cut Property: https://www.youtube.com/watch?v=P7K7mG8QDVM
    * Proof of Prim's MST algorithm using cut property: https://www.youtube.com/watch?v=UfhUr5QzfiI
    * Correctness of Kruskal's Algorithm: https://www.youtube.com/watch?v=S9PIItOUyzA
  * Example Code: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/MinimumSpanningTree.cpp    
* Lowest Common Ancestor (LCA):
  * General Overview of Methods:
    * http://codeforces.com/blog/entry/16221 (skip to the LCA part)
  * Sparse Tables and LCA: https://www.youtube.com/watch?v=EKcQt-74bNw
  * Method 1 (RECOMMENDED): Binary Lifting Method (aka jump pointers: https://en.wikipedia.org/wiki/Level_ancestor_problem#Jump_pointer_algorithm):
    * http://codeforces.com/blog/entry/22325
      * Note: as the post says, this method is very handy as it can be also used to compute querys over paths in Trees
    * https://www.youtube.com/watch?v=kOfa6t8WnbI
  * Method 2: Euler Tour + Range Minimun Query:
    * https://www.topcoder.com/community/data-science/data-science-tutorials/range-minimum-query-and-lowest-common-ancestor/
    * Sparse Table Algorithm Range Minimum Query: https://www.youtube.com/watch?v=c5O7E_PDO4U
  * Example Code of Both Methods:
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/LCA.cpp
* Level Ancestor:
  * https://en.wikipedia.org/wiki/Level_ancestor_problem
  * https://www.quora.com/Why-does-storing-log-N-pointers-work-in-the-jump-pointer-solution-of-the-level-ancestor-problem
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/LA.cpp
* Heavy-Light Decomposition:
  * https://blog.anudeep2011.com/heavy-light-decomposition/
  * https://www.geeksforgeeks.org/heavy-light-decomposition-set-1-introduction/
  * http://codeforces.com/blog/entry/22072
* Max Flow:
  * Episode 33 - Maximum Flow Intuition: https://www.youtube.com/watch?v=K1i-wP82Zdo
  * Cuándo se usa:
     * (MUY RECOMENDADO) Ejemplos de problemas usando flujo: https://www.youtube.com/watch?v=nKcVc8XkFSA
     * Maximum Bipartite Matching: http://www.geeksforgeeks.org/maximum-bipartite-matching/  
  * Ford-Fulkerson Algorithm:
     * https://www.youtube.com/watch?v=Tl90tNtKvxs
     * https://www.youtube.com/watch?v=XPpmzulEmjA
     * https://www.youtube.com/watch?v=MczX0SM3I84
     * https://www.youtube.com/watch?v=GiN3jRdgxU4
     * Intuición detrás del grafo residual: https://cs.stackexchange.com/questions/55041/residual-graph-in-maximum-flow
  * Dinic Algorithm (RECOMENDADO):
     * https://www.youtube.com/watch?v=uM06jHdIC70
     * http://www.cs.cmu.edu/afs/cs.cmu.edu/academic/class/15451-f14/www/lectures/lec11/dinic.pdf
     * http://theory.stanford.edu/~tim/w16/l/l2.pdf
     * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Graphs/Dinic.cpp


### Data Structures:
* Union Find (Disjoint Sets):
  * https://www.youtube.com/watch?v=ID00PMy0-vE
  * http://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Data_Structures/unionfind.cpp
* Segment Tree:
  * http://progcomp.cl/segmenttree
  * https://www.youtube.com/watch?v=ZBHKZF5w4YU
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Data_Structures/segment-tree.cpp
* Segment Tree Lazy: 
   * Lazy Propagation Segment Tree: https://www.youtube.com/watch?v=xuoQdt5pHj0
   * Segment Tree - Range Queries with Lazy Updates: https://www.youtube.com/watch?v=CN0N1ddJ9hA
   * Implementaciones de Ejemplo:
     * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Data_Structures/segment-tree-lazy.cpp
     
* Fenwick Tree (a.k.a. BIT o Binary Indexed Tree):
  * [HackerEarth - binary indexed tree made easy](https://www.hackerearth.com/practice/notes/binary-indexed-tree-made-easy-2/)
  * (recomendado) (explicación de Jorge Pérez) https://youtu.be/0PzR0IoqkkU?t=2160
    * https://youtu.be/0PzR0IoqkkU?t=1453 (por si quieren ver la explicación de **sweep line** también que viene justo antes)
  * (recomendado) https://www.youtube.com/watch?v=CWDQJGaN1gY
  * http://progcomp.cl/fenwicktree
  * https://cs.stackexchange.com/questions/10538/bit-what-is-the-intuition-behind-a-binary-indexed-tree-and-how-was-it-thought-a
  * https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/
* Fenwick Tree 2D:
  * http://www.geeksforgeeks.org/two-dimensional-binary-indexed-tree-or-fenwick-tree/
  * (explicación de Jorge Pérez) https://youtu.be/0PzR0IoqkkU?t=4207
  * https://www.topcoder.com/community/data-science/data-science-tutorials/binary-indexed-trees/#2d
* Wavelet Tree: https://www.dcc.uchile.cl/~jperez/papers/ioiconf16.pdf

### Strings:
* Rolling Hashing:
  * https://progcomp.cl/rollinghashing
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/RollingHashing.cpp
* Suffix Array:
  * ¿Qué es un suffix array?: [Youtube - Suffix Array introduction](https://www.youtube.com/watch?v=zqKlL3ZpTqs)
  * HackerRank - Suffix Array: https://www.hackerrank.com/challenges/ashton-and-string/topics/suffix-array
  * Suffix Array Construction: https://www.cs.helsinki.fi/u/tpkarkka/opetus/10s/spa/lecture11.pdf
  * Códigos de Ejemplo:
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/suffix_array.cpp
    * http://codeforces.com/blog/entry/4025
* Trie:
  * https://en.wikipedia.org/wiki/Trie
  * https://www.youtube.com/watch?v=zIjfhVPRZCg
  * https://www.youtube.com/watch?v=AXjmTQ8LEoI
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/Trie.cpp
* KMP (String Pattern Matching):
  * https://www.youtube.com/watch?v=v82y5TCcBhQ
  * https://www.youtube.com/watch?v=V5-7GzOfADQ
  * https://www.youtube.com/watch?v=GTJr8OvyEVQ
  * https://www.youtube.com/watch?v=KG44VoDtsAA
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/KMP.cpp
* Shortest Repeating Cycle:
  * http://www.geeksforgeeks.org/find-given-string-can-represented-substring-iterating-substring-n-times/
  * http://stackoverflow.com/questions/6021274/finding-shortest-repeating-cycle-in-word
  * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Strings/shortest_repeating_cycle.cpp

### Mathematics:
* Números Primos:
  *  ¿Qué es un número primo?
     * [What's a Prime Number?](https://www.youtube.com/watch?v=9pgA-H77BLc)
     * [Wikipedia - Prime Number](https://en.wikipedia.org/wiki/Prime_number)
  * Teorema fundamental de la aritmética: todo natural tiene una única factorización prima
     * [wikipedia - Fundamenetal theorem of arithmetic](https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)
     * [The Fundamental Theorem of Arithmetic](http://www.oxfordmathcenter.com/drupal7/node/165)
     * [Number Theory - Fundamental Theorem of Arithmetic](https://www.youtube.com/watch?v=7sw6LdAfHgE)
  * Tests de Primalidad (cómo saber si un número es primo):
    * [CP-Algorithms: Primality tests](https://cp-algorithms.com/algebra/primality_tests.html)
    * [stackoverflow - Fastest algorithm for primality test](https://stackoverflow.com/questions/2586596/fastest-algorithm-for-primality-test)
    * Miller Rabin:
      * [cp-algorithms: Miller Rabin](https://cp-algorithms.com/algebra/primality_tests.html#toc-tgt-2)
      * https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/
      * deterministic variant: https://miller-rabin.appspot.com/
  * Criba de Eratóstenes (todos los primos hasta N):
    * [Finding Prime numbers - Sieve of Eratosthenes](https://www.youtube.com/watch?v=eKp56OLhoQs)
    * [Criba de Eratóstenes [ICPCCL 2016]](https://www.youtube.com/watch?v=J4QCQ0dgeCI)
    * https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes
    * [Código de ejemplo](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/prime_numbers.cpp)
  * Criba de Eratóstenes Segmentada (más rápida):
    * https://github.com/kimwalisch/primesieve/wiki/Segmented-sieve-of-Eratosthenes
    * https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html#toc-tgt-6
    * https://www.geeksforgeeks.org/segmented-sieve-print-primes-in-a-range/
  * Factorización Prima de Números Enteros:
    * [cp-algorithms: Integer factorization](https://cp-algorithms.com/algebra/factorization.html)
  * Factorización Prima de Factoriales:
    * [Prime Factorization of Factorial](https://forthright48.com/prime-factorization-of-factorial/)
    * [Prime Factorization of Factorials](http://mathforum.org/library/drmath/view/67291.html)

* Aritmética Modular:
  * ¿De qué se trata Aritmética Modular?
    * [Art of Problem Solving: Modular Arithmetic / Introduction](https://artofproblemsolving.com/wiki/index.php/Modular_arithmetic/Introduction)
    * [Wikipedia - Modular Arithmetic](https://en.wikipedia.org/wiki/Modular_arithmetic)
    * [Introduction to Modular arithmetic](https://www.youtube.com/watch?v=9lUSKOjV4d0)
    * [High level introduction to modular arithmetic](https://www.youtube.com/watch?v=r0gYad8auYY)
    * [Congruence (Modular Arithmetic) & 5 Properties Explained with 7 Problems: Ultimate Shortcuts](https://www.youtube.com/watch?v=B1gD6540uWA)
  * Modular Inverse:
    * [cp-algorithms - Modular Inverse](https://cp-algorithms.com/algebra/module-inverse.html)
    * [Youtube - Multiplicative inverses mod n](https://www.youtube.com/watch?v=_bRVA5b4sb4)
  * Modular Exponentiation By Squaring:
    * https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/binary_modular_exponentiation.cpp
  * Modular Fibonacci with Exponentiation by Squaring:
    * http://mathoverflow.net/questions/40816/fibonacci-series-mod-a-number  
* Euler's Theorem & Euler's Totient Function:
  * [wikipedia - Euler's Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)
  * [wikipedia - Euler's Totient Function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)
  * [cp-algorithms: Euler's Totient Function](https://cp-algorithms.com/algebra/phi-function.html)
* Binary Exponentiation:
  * [cp-algorithms - Binary Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)  
* Conteo y Combinatoria modular:
  * [Muy buen artículo sobre distintos métodos para calcular combinatorias](https://comeoncodeon.wordpress.com/2011/07/31/combination/)
  * Modular Binomial Coefficient (Choose(n,k) mod X):
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/modular_binomial_coefficient.cpp
  * Modular Multinomial Coefficient:
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/modular_multinomial_coefficient.cpp
* Algoritmo de Euclides (cómo encontrar el GCD entre dos números):
    * [youtube - Euclidean Algorithm (Proof)](https://www.youtube.com/watch?v=H_2_nqKAZ5w)
    * [youtube - Number Theory: Euclidean Algorithm - An example](https://www.youtube.com/watch?v=fwuj4yzoX1o)    
    * [cp-algorithms: Euclidean algorithm for computing the greatest common divisor](https://cp-algorithms.com/algebra/euclid-algorithm.html)
    * [youtube - (Discrete Math 1) Euclidian Algorithm](https://www.youtube.com/watch?v=cOwyHTiW4KE)
    * [Euclidean Algorithm – Greatest Common Divisor](https://forthright48.com/euclidean-algorithm)      
    * [geeksforgeeks - std::gcd | C++ inbuilt function for finding GCD](https://www.geeksforgeeks.org/stdgcd-c-inbuilt-function-finding-gcd/)
* Algoritmo de Euclides Extendido (a.k.a. GCD extendido, gcdext):
  * [extended euclidean algorithm](https://forthright48.com/extended-euclidean-algorithm/)
  * [cp-algorithms: Extended Euclidean Algorithm](https://cp-algorithms.com/algebra/extended-euclid-algorithm.html)
  * [gcdext con números negativos?](https://math.stackexchange.com/questions/37806/extended-euclidean-algorithm-with-negative-numbers)
  * [youtube - Algoritmo de Euclides [ICPCCL 2016]](https://www.youtube.com/watch?v=k47fkSULGr0)
  * [youtube - The Extended Euclidean algorithm](https://www.youtube.com/watch?v=hB34-GSDT3k)
  * [código de ejemplo](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/euclidean_algorithm.cpp)  
* Linear Diophantine Equations:
  * [N1--Introduction to Linear Diophantine Equations](https://www.youtube.com/watch?v=TIk3ujphMfk)
  * [N2--Solve Basic Linear Diophantine Equation](https://www.youtube.com/watch?v=5DcoG69NyO0)
  * [Number Theory: Diophantine Equation: ax+by=gcd(a,b)](https://www.youtube.com/watch?v=FjliV5u2IVw)
  * https://cp-algorithms.com/algebra/linear-diophantine-equation.html  
* Linear Congruence Equation:
  * [cp-algorithms: Linear Congruence Equation](https://cp-algorithms.com/algebra/linear_congruence_equation.html)
* Chinese Remainder Theorem (CRT):
  * [youtube - The Chinese Remainder Theorem made easy](https://www.youtube.com/watch?v=ru7mWZJlRQg)
  * [youtube - Chinese Remainder Theorem](https://www.youtube.com/watch?v=zIFehsBHB8o)
  * [codeforces - [Tutorial] Chinese Remainder Theorem](https://codeforces.com/blog/entry/61290)
  * [Chinese Remainder Theorem Part 1 – Coprime Moduli](https://forthright48.com/chinese-remainder-theorem-part-1-coprime-moduli/)
  * [Chinese Remainder Theorem Part 2 – Non Coprime Moduli](https://forthright48.com/chinese-remainder-theorem-part-2-non-coprime-moduli)
  * [código de ejemplo](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/chinese_remainder_theorem.cpp)  
* Lucas's theorem:
  * [wikipedia - Lucas's theorem](https://en.m.wikipedia.org/wiki/Lucas%27s_theorem)
  * [choose(n,k) mod M using Chinese remainder theorem?](https://math.stackexchange.com/questions/95491/n-choose-k-bmod-m-using-chinese-remainder-theorem)  
* Integración Numérica:
  * Wikipedia: https://en.wikipedia.org/wiki/Numerical_integration
  * Codeforces: Tasks involving numerical integration: https://codeforces.com/blog/entry/8242
  * Explanation of Simpson's rule | MIT 18.01SC Single Variable Calculus, Fall 2010: https://www.youtube.com/watch?v=uc4xJsi99bk
  * Simpson's Rule & Numerical Integration: https://www.youtube.com/watch?v=7EqRRuh-5Lk
  * Numerical Integration With Trapezoidal and Simpson's Rule: https://www.youtube.com/watch?v=RTX-ik_8i-k    

### Geometry:
* Video Repaso de Geometría (SÚPER BUENO):
  * Geometría Computacional [ICPCCL 2016]: https://youtu.be/nk5ejrBWORw?list=PL-c_98SOXhxaXMMfnemh2ihniZsj57L8-
* Geometry: 2D points and lines [Tutorial]: https://codeforces.com/blog/entry/48122
* Cross Product and Dot Product: Visual explanation: https://www.youtube.com/watch?v=h0NJK4mEIJU
* Producto Cruz:
  * Cross Product - Math is fun: https://www.mathsisfun.com/algebra/vectors-cross-product.html
  * Cross products | Essence of linear algebra, Chapter 10: https://www.youtube.com/watch?v=eu6i7WJeinw
  * Calculating a 2D Vector's Cross Product: https://stackoverflow.com/questions/243945/calculating-a-2d-vectors-cross-product
  * https://codeforces.com/blog/entry/48122 (saltarse a la parte cross product)
* Producto Punto:
  * https://codeforces.com/blog/entry/48122 (saltarse a la parte dot product)
  * Dot Product & Angle Between Vectors: https://www.youtube.com/watch?v=p8BZTFNSKIw
* Códigos varios de geometría 2D: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/Geometry2DUtils.cpp. Incluye:
  * Ejemplo de un struct Point
  * Producto Cruz: Orientación de un punto respecto a un rayo (left, collinear o right)
    * basado en: https://www.geeksforgeeks.org/orientation-3-ordered-points/
  * Ordenar segmentos disjuntos por orden de intersección respecto a un rayo usando producto cruz
  * Detectar intersección de rectángulos
  * Detectar intersección de segmentos
    * basado en: https://www.geeksforgeeks.org/check-if-two-given-line-segments-intersect/
  * Detectar intersección de círculos
  * Distancia punto - segmento
    * basado en: https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment
  * Distancia punto - recta
  * Hashing de ecuación de recta a partir de 2 puntos
* Trigonometría: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/Trigonometry.cpp. Incluye:
  * Cálculo del ángulo de un vector 2D (medido ccw con respecto x+) usando atan2(y,x)
  * Implementación del teorema del coseno para cálcular ángulos internos de triángulos
* Cálculo de Áreas:
  * Teorema de Green (aplicado al caso particular de calcular áreas):
    * lecturas:
        * https://math.stackexchange.com/questions/199003/proving-greens-theorem-for-computing-area
        * https://mathinsight.org/greens_theorem_find_area
    * videos:
        * Green's Theorem: https://www.youtube.com/watch?v=a_zdFvYXX_c
        * 78 - Finding area with Green's theorem: https://www.youtube.com/watch?v=42vEvHpXYP8
        * How to Use Green's Theorem to Find the Area of A Region: https://www.youtube.com/watch?v=w3ugdu0oFgE
        * Green's Theorem: area under an arch | MIT 18.02SC Multivariable Calculus, Fall 2010: https://www.youtube.com/watch?v=KXof0q88xbg
    * Código ejemplo: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/GreensTheorem.cpp
  * Área de un polígono simple:
    * http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/
    * http://stackoverflow.com/questions/451426/how-do-i-calculate-the-area-of-a-2d-polygon    
    * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/PolygonArea.cpp
* Sweep Line y Radial Sweep Line:
  * https://en.wikipedia.org/wiki/Sweep_line_algorithm
  * https://www.topcoder.com/community/data-science/data-science-tutorials/line-sweep-algorithms/
  * http://codeforces.com/blog/entry/20377
  * https://apps.topcoder.com/forums/?module=Thread&threadID=684537&start=0&mc=6
* Detectar si un punto está dentro de un polígono:
  * http://geomalgorithms.com/a03-_inclusion.html
  * https://en.wikipedia.org/wiki/Point_in_polygon
  * Código ejemplo: https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/PointInPolygon.cpp
  * Point in Convex Polygon: http://stackoverflow.com/questions/1119627/how-to-test-if-a-point-is-inside-of-a-convex-polygon-in-2d-integer-coordinates
* Dualidad Línea Punto:
  * Buenas slides explicando dualidad: https://algo.kaust.edu.sa/Documents/cs372l13.pdf
  * Excelente pdf con demostraciones: https://pdfs.semanticscholar.org/810c/e0c19283481567c6545bf8c0cc8a4dcb8a1f.pdf  
  * Aplicación interactiva: http://students.cec.wustl.edu/~tdeck/duality/
* Convex Hull:
  * Buen video explicando Convex Hull: https://www.youtube.com/watch?v=wRTGDig3jx8
  * Monotone Chain Algorithm (algoritmo recomendado):
    * Video animación: https://www.youtube.com/watch?v=A4uWWnzTplM
    * Ejemplos de implementaciones:
      * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
      * https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Geometry/ConvexHull.cpp
* Convex Hull Trick:
  * https://wcipeg.com/wiki/Convex_hull_trick
  * https://stackoverflow.com/questions/17834699/what-is-convex-hull-trick-exactly

### Square Root Decomposition
  * [cp-algorithms: square decomposition](https://cp-algorithms.com/data_structures/sqrt_decomposition.html)
  * Mo's Algorithm:
    * [cp-algorhtms: Mo's algorithm](https://cp-algorithms.com/data_structures/sqrt_decomposition.html#toc-tgt-4)
    * [geeksforgeeks: Mo's algorithm (query square root decomposition)](https://www.geeksforgeeks.org/mos-algorithm-query-square-root-decomposition-set-1-introduction/)
    * [geeksforgeeks: extended Mo's algorithm (O(1) time complexity)](https://www.geeksforgeeks.org/extended-mos-algorithm-o1-time-complexity/)
_______________________________________________

# Contests
* Contest 1, Marzo 08, 10 días, Implementación & Backtracking, [link a **contest**](https://vjudge.net/contest/285945), [link a **explicaciones**](https://docs.google.com/document/d/1c6FljbO2lOPGZj6t9NaaOFe9K9LcztIbCjyuOpiE70k/edit?usp=sharing)
  * **Puntos**: 4, 4, 4, 3, 3, 3, 2    **Puntaje Mínimo Esperado**: 4.4
  * **códigos de ejemplo**: [A - 8 queens chess problem](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/750_8-Queens-Chess-Problem.cpp) [A - 8 Queens chess problem - version ignacio](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/8_Queen_Cheess_Problem.cpp), [B - A problem of Backtracking](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/BTCK_A-problem-of-Backtracking.cpp) [B - A problem of Backtracking - versión Ignacio](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/SPOJ/BTCK%20-%20A%20problem%20of%20Backtracking/BTCK%20-%20A%20problem%20of%20Backtracking.cpp), [C - Map Colouring](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/MapColouring.cpp), [D - Vitamins](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/1042B_Vitamins.cpp), [F - Adding Words](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/AddingWords.cpp), [G - Reversed Binary Numbers](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/ReversedBinaryNumbers.cpp).

* Contest 2, Marzo 15, 10 días, Implementación & Backtracking, [link a **contest**](https://vjudge.net/contest/288151), [link a **explicaciones**](https://docs.google.com/document/d/1y4-okA-4KlmQfAs7-aHBikULGor1mLt5dxvCKgL2Ogc/)
  * **enunciados**: [A](https://vjudge.net/problem/1162860/origin), [B](https://vjudge.net/problem/509134/origin), [C](https://vjudge.net/problem/52968/origin), [D](https://vjudge.net/problem/2280568/origin), [E](https://uva.onlinejudge.org/external/4/441.pdf), F([1](https://uva.onlinejudge.org/external/5/574.pdf),[2](https://icpcarchive.ecs.baylor.edu/external/53/5319.pdf)), [G](https://vjudge.net/problem/613719/origin)
  * **Puntos**: 5, 4, 3, 4, 3, 4, 3    **Puntaje Mínimo Esperado**: 5.4
  * **códigos de ejemplo**: [A - Tight Fit Sudoku](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/TightFitSudoku.cpp),		[B - All About That Base](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/AllAboutThatBase.cpp),		[C - ALL IZZ WELL](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/ALLIZWEL.cpp),
[D - Zagrade](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/Kattis/Zagrade/Zagrade.cpp) [D - Zagrade - version Pablo](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/Zagrade.cpp), [E - Lotto](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/441_Lotto.cpp), [F - Sum It Up](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/5319_SumItUp.cpp), [G - Pizza Hawaii](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/PizzaHawaii.cpp)

* Contest 3, Marzo 22, 10 días, Implementación & Backtracking, [link a **contest**](https://vjudge.net/contest/289571), [link a **explicaciones**](https://docs.google.com/document/d/1IqP8cwuGTmsfBduOK4HHiSoMKvXhDdr58thltLdYEg0/edit?usp=sharing)
  * **enunciados**: [A](https://vjudge.net/problem/14556/origin), [B](https://vjudge.net/problem/1162851/origin), [C](https://vjudge.net/problem/24139/origin), [D](https://vjudge.net/problem/680588/origin), [E](https://vjudge.net/problem/28532/origin), [F](https://vjudge.net/problem/19668/origin), [G](https://vjudge.net/problem/43047/origin), [H](https://vjudge.net/problem/812880/origin)
    * Sobre el B - Magical Mystery Knight's Tour: si pasan 51/52 test cases está bien (Kattis tiene un tiempo muy estricto para el test case 52, si pasan los primeros 51 test cases y en el 52 les da TLE el problema igual está bueno).
  * **Puntos**: 6, 7, 5, 5, 4, 3, 5, 3  **Puntaje Mínimo Esperado**: 5.4
  * **códigos de ejemplo**: [A - Report Recovery](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/3658_ReportRecovery.cpp), [B - Magical Mystery Knight's Tour](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/MagicalMysterKnightsTour.cpp), [D - Association for Cool Machineries (Part 1)](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/AssociationForCoolMachineries(part1).cpp), E - Distributing Ballot Boxes: ([v1-priority_queue](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/5822_DistributingBallotBoxes.cpp), [v2-binsearch](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/5822_DistributingBallotBoxes_v2.cpp)), [F - Mapping the Swaps](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/331_MappingTheSwaps.cpp), [H - Touchscreen Keyboard](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/TouchscreenKeyboard.cpp)
  
* Contest 4, Marzo 29, 10 días, Binary Search, [link a **contest**](https://vjudge.net/contest/291141), [link a **explicaciones**](https://docs.google.com/document/d/12PdCr1fCv3uCrzu_nIEaZ6EjMQpxhSfWdn7Tta2GuJk/edit)
  * **enunciados**: [A](https://vjudge.net/problem/1983901/origin),		[B](https://vjudge.net/problem/1983915/origin),		[C](https://vjudge.net/problem/21635/origin),		[D](https://vjudge.net/problem/27471/origin),		[E](https://vjudge.net/problem/32603/origin),		[F](https://vjudge.net/problem/89213/origin),		[G](https://vjudge.net/problem/344888/origin),		[H](https://vjudge.net/problem/687762/origin)
  * **Puntos**: 2, 2, 5, 4, 5, 3, 4, 4  **Puntaje Mínimo Esperado**: 6.4
  * **códigos de ejemplo**: [A - Busqueda Binaria](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/BBIN_BusquedaBinaria.cpp),		[B - Búsqueda Binaria 2](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/BBIN2_B%C3%BAsquedaBinaria2.cpp),		[C - Berland Collider](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/24E_BerlandCollider.cpp),	[D - Fill the Containers](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/11413_FillTheContainers.cpp),	[E - Electric Bill](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/4476_ElectricBill.cpp),		[F - Vanya and Lanterns](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/492B_VanyaAndLanterns.cpp), [G - Enduring Exodus](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/645C_EnduringExodus.cpp),		[H - The Meeting Place Cannot Be Changed](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/780B_TheMeetingPlaceCannotBeChanged.cpp)

* Contest 5, Abril 04, 11 días, Binary Search, [link a **contest**](https://vjudge.net/contest/292283), [link a **explicaciones**](https://docs.google.com/document/d/1lWBleXlsS9xN0UT2Ke4mUlX5eiwp9PEXJt8gxFieM3g/edit)
  * **enunciados**: [A](https://vjudge.net/problem/34983/origin),		[B](https://vjudge.net/problem/1929872/origin),		[C](https://vjudge.net/problem/139137/origin),		[D](https://vjudge.net/problem/1057369/origin),		[E](https://vjudge.net/problem/2225616/origin),		[F](https://vjudge.net/problem/827112/origin),		[G](https://vjudge.net/problem/2037788/origin),		[H](https://vjudge.net/problem/244517/origin)
  * **Puntos**: 5, 5, 5, 4, 6, 3, 4, 6  **Puntaje Mínimo Esperado**: 5.6
  * **códigos de ejemplo**: [A - Environment Protection](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/6135_EnvironmentProtection.cpp), [B - Nature reserve](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/nature_reserve.cpp), [C - The Art of Dealing with ATM](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/524C_TheArtOfDealingWithATMs.cpp), [D - Freight Train](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/FreightTrain.cpp), [F - Need for Speed](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/NeedForSpeed.cpp), [H - Weakness and Poorness](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/579E_WeaknessAndPoorness.cpp)
  
* Contest 6, Abril 11, 11 días, Dynamic Programming (DP), [link a **contest**](https://vjudge.net/contest/293759), [link a **explicaciones**](https://docs.google.com/document/d/10ThVY2nNsZkppj7fOP3u8CoRrAkL519EVApUStaAf5c/edit)
  * **enunciados**: [A](https://vjudge.net/problem/18381/origin),		[B](https://vjudge.net/problem/588845/origin),		[C](https://vjudge.net/problem/23734/origin),		[D](https://vjudge.net/problem/53356/origin),		[E](https://vjudge.net/problem/20886/origin),		[F](https://vjudge.net/problem/20931/origin),		[G](https://vjudge.net/problem/20930/origin),		[H](https://vjudge.net/problem/20929/origin)
  * **Puntos**: 3, 3, 5, 4, 6, 4, 4, 6  **Puntaje Mínimo Esperado**: 6
  * **códigos de ejemplo**: [A - Staircases](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/acm.timus.ru/1017_Staircases.cpp), [B - The Coin Change Problem](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/hackerrank/TheCoinChangeProblem.cpp), [E - Nested Dolls](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/MDOLLS_NestedDolls.cpp), [F - Scuba diver](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/SCUBADIV_ScubaDiver.cpp), [G - Mixtures](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/MIXTURES_Mixtures.cpp), [H - Card Sorting](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/MCARDS_CardSorting.cpp)
  
* Contest 7, Abril 18, 11 días, Dynamic Programming (DP), [link a **contest**](https://vjudge.net/contest/296015), [link a **explicaciones**](https://docs.google.com/document/d/1QuYmoixfoMGeOs8AImV0t0lEndgysknR8eX3gJQXpu8/edit)
  * **enunciados**: [A](https://vjudge.net/problem/80113/origin),		[B](https://vjudge.net/problem/1284100/origin),		[C](https://vjudge.net/problem/47664/origin),		[D](https://vjudge.net/problem/21861/origin),		[E](https://vjudge.net/problem/25712/origin),		[F](https://vjudge.net/problem/20884/origin),		[G](https://vjudge.net/problem/47155/origin),		[H](https://vjudge.net/problem/1378602/origin)
  * **Puntos**: 6, 7, 7, 5, 5, 4, 5, 4    **Puntaje Mínimo Esperado**: 5
  * **códigos de ejemplo**: [B - Arranging Tiles](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/ArrangingTiles.cpp), [C - Eleven](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/12672_Eleven.cpp), [D - Chess](https://github.com/mmunos/cp/tree/master/Z_trening/414%20-%20Chess), [E - Looking for Order](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/8C_LookingForOrder.cpp), [H - Enigma](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/8192_Enigma.cpp)
  
* Contest 8, Abril 25, 11 días, Greedy, [link a **contest**](https://vjudge.net/contest/297681), [link a **explicaciones**](https://docs.google.com/document/d/1rVzlaa4fW3SVvK86FsuhRwYnt2ZxwhtD0nodskgU2Fc/edit?usp=sharing)
  * **enunciados**: [A](https://vjudge.net/problem/53114/origin),		[B](https://vjudge.net/problem/254404/origin),		[C](https://vjudge.net/problem/527241/origin),		[D](https://vjudge.net/problem/1263975/origin),		[E](https://vjudge.net/problem/908661/origin),		[F](https://vjudge.net/problem/1971708/origin),		[G](https://vjudge.net/problem/21533/origin),		[H](https://vjudge.net/problem/908042/origin)
  * **Puntos**: 4, 4, 4, 3, 3, 4, 3, 3    **Puntaje Mínimo Esperado**: 5.4
  * **códigos de ejemplo**: [C - Exams](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/732D_Exams.cpp)
 
 * Contest 9, Mayo 02, 11 días, Grafos (BFS / DFS), [link a **contest**](https://vjudge.net/contest/298372), [link a **explicaciones**](https://docs.google.com/document/d/1LvIzS4kxBqM4v0tsTqdYN0FKlRM5G67bPyPUcTcp3ZY/edit)
   * **enunciados**: [A](https://vjudge.net/problem/306223/origin),		[B](https://vjudge.net/problem/2163530/origin),		[C](https://vjudge.net/problem/283837/origin),		[D](https://vjudge.net/problem/1477149/origin),		[E](https://vjudge.net/problem/77099/origin),		[F](https://vjudge.net/problem/47669/origin),		[G](https://vjudge.net/problem/418793/origin),		[H](https://vjudge.net/problem/13068/origin)
   * **Puntos**: 3, 4, 5, 5, 4, 6, 5, 4  **Puntaje Mínimo Esperado**: 5.6
   * **códigos de ejemplo**: [A - The Labyrinth](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/Codeforces/616C_TheLabyrinth.cpp), [C - Exposing corruption](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/7207_ExposingCorruption.cpp), [E - Intrepid Climber (Python & Cpp)](https://github.com/ignaciohermosillacornejo/competitive_programming/tree/master/URI/Intrepid%20Climber/), [F - Join two kingdoms](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JoinTwoKingdoms.cpp), [H - Geophysics Prospection](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/4010_GeophysicsProspection.cpp) 

* Contest 10, Mayo 09, 13 días, Grafos - shortest paths(dijkstra, bellman-ford, floyd-warshall), [link a **contest**](https://vjudge.net/contest/300689), [link a **explicaciones**](https://docs.google.com/document/d/1ieyUsYv_3lP1AYQ8vqvpcFcaG4qQtCxKnZHE5wCa1ck/edit)
   * **enunciados**: [A](https://vjudge.net/problem/20817/origin),		[B](https://vjudge.net/problem/38280/origin),		[C](https://vjudge.net/problem/20795/origin),		[D](https://vjudge.net/problem/14550/origin),		[E](https://vjudge.net/problem/14038/origin),		[F](https://vjudge.net/problem/16798/origin),		[G](https://vjudge.net/problem/20716/origin),		[H](https://vjudge.net/problem/1165069/origin)
   * **Puntos**: 4,	5,	4,	4,	5,	6,	5,	4  **Puntaje Mínimo Esperado**: 6.4
   * **códigos de ejemplo**: [E - Almost Shortest Path](https://github.com/mmunos/cp/tree/master/live%20archive/2008%20Latin%20America/4210%20-%20Almost%20Shortest%20Path), [H - All Pairs Shortest Path](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/Kattis/All%20Pairs%20Shortest%20Path/All%20Pairs%20Shortest%20Path.cpp)
   
* Contest 11, Mayo 16, 11 días, Grafos - shortest paths + toposort, [link a **contest**](https://vjudge.net/contest/301435), [link a **explicaciones**](https://docs.google.com/document/d/1TDdEJDrhs8NlISViE8ZEM-Wymeg5uFeoIm4b_fwCNGA/edit)
   * **enunciados**: _pending_
   * **Puntos**: 3,	5,	6,	3,	4,	4,	4  **Puntaje Mínimo Esperado**: 6
   * **códigos de ejemplo**: [A - Wormholes](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/Live%20Archive%20%26%20UVa/Wormholes/Wormholes.cpp), [B - Galactic Taxes](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/13010_GalacticTaxes.cpp), [C - Keep it Energized](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/7213_KeepItEnergized_v2.cpp), [E - Build Dependencies](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/BuildDependencies.cpp)
   
 
* Contest 12, Mayo 23, 11 días, Números Primos, [link a **contest**](https://vjudge.net/contest/303565), [link a **explicaciones**](https://docs.google.com/document/d/1FftVrfQtqcBDtWdv2ZE1DfpmICeSbs-Fop27TBVSKU4/edit)
   * **enunciados**: _pending_
   * **Puntos**: 3, 4, 2, 8, 4, 4, 5, 4, 4  **Puntaje Mínimo Esperado**: 6
   * **códigos de ejemplo**: [A - Prime Generator](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/PRIME1_PrimeGenerator.cpp), [B - Prime Intervals](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/PRINT_PrimeIntervals.cpp), [B - Prime Intervals Ignacio](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/SPOJ/PRINT%20-%20Prime%20Intervals/PRINT%20-%20Prime%20Intervals.cpp), [C - Almost Prime](https://github.com/ignaciohermosillacornejo/competitive_programming/blob/master/Code%20Forces/Almost%20Prime/Almost%20Prime.cpp), [D - Prime Spiral](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/PrimeSpiral.cpp), [E - Prime Reduction](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/PrimeReduction.cpp), [H - Just in Time](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JustInTime.cpp), [I - Finding Primes](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/FINDPRM_FindingPrimes.cpp)
   
* Contest 13, Mayo 30, 11 días, Mix de Mate (gcd, modular arithmetics, binary exponentiaion, etc.), [link a **contest**](https://vjudge.net/contest/304342), link a **explicaciones**: _pending_
   * **enunciados**: _pending_
   * **Puntos**: 7, 4, 6, 3, 5, 4, 10, 4, 2  **Puntaje Mínimo Esperado**: 6
   * **códigos de ejemplo**: [A - Yet Another Multiple Problem](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/SPOJ/MULTII_YetAnotherMultipleProblem.cpp), [E - Last Digit](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/4008_LastDigit.cpp), [G - Bases](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/12145_Bases.cpp), [H - Even Distribution](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/6825_EvenDistribution.cpp)
 
* Contest 14, Junio 06, 11 días, Conteo y combinatoria modular, [link a **contest**](https://vjudge.net/contest/305525), [link a **explicaciones**](https://docs.google.com/document/d/1vZpOS2OJgORY3rm3r8r4e-2vK1dSiKvj90dFeCNcMKs/edit)
   * **enunciados**: _pending_
   * **Puntos**: _pending_  **Puntaje Mínimo Esperado**: _pending_
   * **códigos de ejemplo**: [B - Eleven](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/UVA/12672_Eleven.cpp), [E - Knights of the Round Table](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/6831_KnightsOfTheRoundTable.cpp), [H - Jumping Frog](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/URI/JumpingFrog.cpp)

* Contest 15, Junio 13, 11 días, euclides extendido (gcdext) y teorema del resto chino (CRT), [link a **contest**](https://vjudge.net/contest/305759), [link a **explicaciones**](https://docs.google.com/document/d/16VCZix2gKmLkSNjKYckUNAQ8E3jAT8S8e1TsVDIsaSI/edit)
   * **enunciados**: _pending_
   * **Puntos**: _pending_  **Puntaje Mínimo Esperado**: _pending_
   * **códigos de ejemplo**: [H - Chinese Remainder Theorem (non...)](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/kattis/generalchineseremainder.cpp)

* Contest 16, Junio 20, 11 días, tutifruti, [link a **contest**](https://vjudge.net/contest/307302), link a **explicaciones**: _pending_
   * **enunciados**: _pending_
   * **Puntos**: _pending_  **Puntaje Mínimo Esperado**: _pending_
   * **códigos de ejemplo**: [E - Height Map](https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Solved%20problems/LiveArchive/7210_HeightMap.cpp)
   
